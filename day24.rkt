#lang racket

(define AND (lambda (a b) (and a b)))
(define OR (lambda (a b) (or a b)))
(define XOR (lambda (a b) (xor a b)))

(define (string->op str)
  (match str
    ("AND" AND)
    ("OR" OR)
    ("XOR" XOR)))

(define (fmt fn)
  (match-define (list hd tl) (string-split (file->string fn) "\r\n\r\n"))
  (list 
   (for/list ((m (regexp-match* #rx"([a-z0-9]+): ([0-9]+)" hd #:match-select cdr)))
     (cons (first m) (string->number (last m))))
   (for/list ((m (regexp-match* #px"([a-z0-9]+) (AND|XOR|OR) ([a-z0-9]+) -> ([a-z0-9]+)" tl #:match-select cdr)))
     (list (string->op (second m)) (first m) (third m) (fourth m)))))

(define (part1 init ops)
  (define ht
    (hash-copy 
     (for/hash ((def init))
       (match-define (cons sym val) def)
       (values sym (not (zero? val))))))
  (let loop ((ht ht) (ops ops))
    (cond ((empty? ops) null)
          (else 
           (match-define (list f a b key) (car ops))
           (cond ((andmap (curry hash-has-key? ht) (list a b))
                  (hash-set! ht key (f (hash-ref ht a) (hash-ref ht b)))
                  (loop ht (cdr ops)))
                 (else (loop ht (append (cdr ops) (list (car ops)))))))))
  (define zkeys (sort (filter (curryr string-prefix? "z") (hash-keys ht)) string>?))
  (define zvalues (for/list ((k zkeys)) (number->string (if (hash-ref ht k) 1 0))))
  (string->number (string-join zvalues "") 2))

(define (part2 init ops)
  (define (find op a b)
    (for/first ((lst ops)
                #:when (and (equal? (first lst) op)
                            (or (and (equal? (second lst) a)
                                     (equal? (third lst) b))
                                (and (equal? (second lst) b)
                                     (equal? (third lst) a)))))
      (fourth lst)))
  (define (index op a b)
    (for/first ((lst ops) (i (length ops))
                          #:when (and (equal? (first lst) op)
                                      (or (and (equal? (second lst) a)
                                               (equal? (third lst) b))
                                          (and (equal? (second lst) b)
                                               (equal? (third lst) a)))))
      i))
  (define (findswaps I i swaplst)
    (define num (~a i #:min-width 2 #:align 'right #:left-pad-string "0"))
    (define X (format "x~a" num))
    (define Y (format "y~a" num))
    (define A (find XOR X Y))
    (define B (find AND X Y))
    (define C (find AND I A))
    (define Z (find XOR I A))
    (define O (find OR C B))

    (if (zero? i)
        (findswaps B (add1 i) swaplst)
        (cond ((> i 43) swaplst) ;; done
              ((not C)
               (define ai (index XOR X Y))
               (define bi (index AND X Y))
               (set! ops (list-set ops ai (list XOR X Y B)))
               (set! ops (list-set ops bi (list AND X Y A)))
               (findswaps I i (append swaplst (list A B))))
              ((string-prefix? A "z")
               (define ai (index XOR X Y))
               (define zi (index XOR I A))
               (set! ops (list-set ops ai (list XOR X Y Z)))
               (set! ops (list-set ops zi (list XOR I A A)))
               (findswaps I i (append swaplst (list A Z))))
              ((string-prefix? B "z")
               (define bi (index AND X Y))
               (define zi (index XOR I A))
               (set! ops (list-set ops bi (list AND X Y Z)))
               (set! ops (list-set ops zi (list XOR I A A)))
               (findswaps I i (append swaplst (list B Z))))
              ((string-prefix? C "z")
               (define ci (index AND I A))
               (define zi (index XOR I A))
               (set! ops (list-set ops ci (list AND I A Z)))
               (set! ops (list-set ops zi (list XOR I A A)))
               (findswaps I i (append swaplst (list C Z))))
              ((string-prefix? O "z")
               (define oi (index OR C B))
               (define zi (index XOR I A))
               (set! ops (list-set ops oi (list OR C B Z)))
               (set! ops (list-set ops zi (list XOR I A O)))
               (findswaps I i (append swaplst (list O Z))))
              (else (findswaps O (add1 i) swaplst)))))
  (string-join (sort (findswaps #f 0 '()) string<?) ","))
  
(module+ test
  (require rackunit)
  (check-equal? (apply part1 (fmt "static/day24example.txt")) 4)
  (check-equal? (apply part1 (fmt "static/day24example02.txt")) 2024)
  (check-equal? (apply part1 (fmt "static/day24input.txt")) 69201640933606)
  (check-equal? (apply part2 (fmt "static/day24input.txt")) "dhq,hbs,jcp,kfp,pdg,z18,z22,z27"))

(module+ main
  (define input (fmt "static/day24input.txt"))
  (printf "day24\n\tpart1: ~a\n\tpart2: ~a\n" (apply part1 input) (apply part2 input)))